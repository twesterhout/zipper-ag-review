\documentclass[runningheads]{llncs}

\usepackage{amsmath}
\usepackage{calc}
\usepackage{csquotes}
\usepackage{color}
\usepackage{comment}
\usepackage[inline,shortlabels]{enumitem}
\usepackage{float}
\usepackage{graphicx}
\usepackage{url}
\usepackage{subcaption}
\usepackage{wrapfig}
\usepackage{pbox}

\captionsetup{compatibility=false}

%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%

%%format .*.       = "\mathbin{.\!\!*\!\!.}"
%%format .=.       = "\mathbin{.\!\!=\!\!.}"
%%format .<.       = "\mathbin{.\!\!<\!\!.}"
%%format sp = " "
%%format qq = "''\!"
%%format .$$ = ".\$_m"
%%format parent' = "parent_m"
%%format  <*>       = "\mathbin{\text{\small\ttfamily{<*>}}}"
%%format  <$>       = "\mathbin{\text{\small\ttfamily{<\$>}}}"
%%format t1 = "t_1"
%%format t2 = "t_2"
%%format constructor' = "constructor_m"
%%%%format Leaf = "{\sf Leaf}"
%%%%format Fork = "{\sf Fork}"
%%format Fork3 = "{\sf Fork3}"
%%%%%%format Root = "{\sf Root}"
%%format CRoot = "C_{\mathit{Root}}"
%%%%%%"{\sf C_{Root}}"
%%format CLeaf = "C_{\mathit{Leaf}}"
%%%%%"{\sf C_{Leaf}}"
%%format CFork = "C_{\mathit{Fork}}"
%%%%% "{\sf C_{Fork}}"
%%format lexeme_Leaf = "lexeme_{\sf Leaf}"
%%format MemoRoot = "{\sf Memo_{Root}}"
%%format MemoFork = "\mathit{Fork}_m"
%%%%%%"{\sf Fork}_m"
%%%%%% "{\sf Memo_{Fork}}"
%%format MemoLeaf = "\mathit{Leaf}_m"
%%%%%%"{\sf Leaf}_m"
%%%%%% "{\sf Memo_{Leaf}}"
%%format treeLookup = "lookup_{MT}"
%%%format MemoTable = "{Cache}"
%%format buildMTree = "\mathit{build}_m"
%%%%%%"build_{MT}"
%%format constructor_m = "\mathit{constructor}_m"
%%format tree_m = "\mathit{tree}_m"
%%format left_m = "\mathit{left}_m"
%%format right_m = "\mathit{right}_m"
%%format constructorM_m = "\mathit{constructorM}_m"
%%format treeM_m = "\mathit{treeM}_m"
%%format leftM_m = "\mathit{leftM}_m"
%%format rightM_m = "\mathit{rightM}_m"
%%format up_m = "\mathit{up}_m"
%%format down_m = "\mathit{down}_m"
%%format modify_m = "\mathit{modify}_m"
%%format mkAG_m = "mkAG_m"
%%format Cxt_m = "\mathit{Cxt}_m"
%%format Root_m = "Root_m"
%%format Top_m = "Top_m"
%%format L_m = "L_m"
%%format R_m = "R_m"
%%format MemoTree = "\mathit{Tree}_m"
%%format ZipperMemoTree = "\mathit{Zipper}_m"
%%format MemoAGTree = "\mathit{AGTree}_m"
%%format C_Memo_RootLet    = "C_{\mathit{Memo\_RootLet   }}"
%%format C_Memo_Let        = "C_{\mathit{Memo\_Let       }}"
%%format C_Memo_In         = "C_{\mathit{Memo\_In        }}"
%%format C_Memo_ConsAssign = "C_{\mathit{Memo\_ConsAssign}}"
%%format C_Memo_ConsLet    = "C_{\mathit{Memo\_ConsLet   }}"
%%format C_Memo_EmptyList  = "C_{\mathit{Memo\_EmptyList }}"
%%format C_Memo_Plus       = "C_{\mathit{Memo\_Plus      }}"
%%format C_Memo_Variable   = "C_{\mathit{Memo\_Variable  }}"
%%format C_Memo_Constant   = "C_{\mathit{Memo\_Constant  }}"
%%format lexemeConsAssign  = "lexeme_{\mathit{ConsAssign}}"
%%format lexemmeConsLet    = "lexeme_{\mathit{ConsLet}}"
%%format calculateMemo     = "calculate_{\mathit{Memo}}"
%%format errsAlgolMemo     = "errs_{\mathit{AlgolMemo}}"
%%format errorsMemo             = "errors_{\mathit{Memo}}"
%%format algol68                = "algol_{\mathit{68}}"
%%format ata_algol68            = "ata\_algol_{\mathit{68}}"
%%format LetSem.constructorMemo = "LetSem.constructor_{\mathit{Memo}}"
%%format lexemeString           = "lexeme_{\mathit{String}}"
%%format upGetVarValueMemo      = "up_{\mathit{GetVarValueMemo}}"
%%format lexemeInt              = "lexeme_{\mathit{Int}}"
%%format Child1              = "Child_{\mathit{1}}"
%%format Child2              = "Child_{\mathit{2}}"
%%format Child3              = "Child_{\mathit{3}}"
%%format Childi              = "Child_{\mathit{i}}"
%%format constructorMemo     = "constructor_{\mathit{Memo}}"
%%format at = "@"
%%format Algol68m               = "Algol68_{\mathit{m}}"

% Formatting
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




\newcommand{\WithMath}[2]{{\parbox[][][b]{\widthof{#1}}{\centering$#2$}}}


% For the circular variant of repmin

% For the specification of AGs

% Tree positions


% A command for declaring todos
\newcommand{\TODO}[1]{{\color[rgb]{1,0,0}\textbf{TODO:}\textit{#1}}}

\newcommand{\ttsub}[2]{{\text{#1}_\text{#2}}}

\newcommand{\Let}{{\sf LET}}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{Modern type-safe embedding of attribute grammars}
\subtitle{An exercise with functional zippers in Haskell}


% TODO(twesterhout): This looks ugly... Someone, reformat it, please :)
\author{Jo{\~a}o Paulo Fernandes\inst{1}%
   \and Pedro Martins\inst{2}%
   \and Alberto Pardo\inst{3}%
   \and Jo{\~a}o Saraiva\inst{4}%
   \and Marcos Viera\inst{3}%
   \and Tom Westerhout\inst{5}%
}
\institute{%
  CISUC -- Universidade de Coimbra, Portugal \email{jpf@dei.uc.pt} \and
  University of California, Irvine, USA \email{pribeiro@uci.edu} \and
  Universidad de la  Rep\'{u}blica, Uruguay, \email{\{pardo,mviera\}@fing.edu.uy} \and
  Universidade do Minho, Portugal, \email{saraiva@di.uminho.pt} \and
  Radboud University, The Netherlands, \email{t.westerhout@student.ru.nl}%
}

\date{}

\maketitle

  % 1) Introduction. In one sentence, what’s the topic?
  % 2) State the problem you tackle
  % 3) Summarize (in one sentence) why nobody else has adequately answered the
  %    research question yet.
  % 4) Explain, in one sentence, how you tackled the research question.
  % 5) In one sentence, how did you go about doing the research that follows
  %    from your big idea.
  % 6) As a single sentence, what’s the key impact of your research?
\begin{abstract}
  Attribute grammars are a powerful, declarative formalism to implement and
  reason about programs which, by design, are conveniently modular. Although a
  full attribute grammar compiler can be tailored to specific needs, its
  implementation is highly non-trivial, and its long-term maintenance is a major
  endeavor. In fact, maintaining a traditional attribute grammar system is such
  a big effort that most systems that were proposed in the past are no longer
  active. Our approach to implementing attribute grammars is to write them as
  first-class citizens of a modern functional programming language. We improve a
  previous zipper-based attribute grammar embedding making it non-intrusive
  (i.e. no changes to the user-defined data types are required) and type-safe.
  On top of that, we achieve clearer syntax by using modern Haskell extensions.
  We believe that our embedding can be employed in practice to implement
  elegant, efficient, and modular solutions to real-life programming challenges.

\keywords{%
       Embedded Domain Specific Languages
  \and Zipper data structure
  \and Memoization
  \and Attribute Grammars
  \and Higher-Order Attribute Grammars
  \and Functional Programming%
}
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}\label{sec:introduction}

  Attribute Grammars (AGs) are a declarative formalism which was proposed by
  Knuth~\cite{Knuth68} in the late 60s and allows one to implement and reason
  about programs in a modular and convenient way. A concrete AG relies on a
  context-free grammar to define the syntax of a language, and on attributes
  associated with the productions of the grammar to define the semantics of that
  language. AGs have been used in practice to specify real programming
  languages, like for example Haskell~\cite{DijkstraFS09}, as well as powerful
  pretty printing algorithms~\cite{SPS99}, deforestation
  techniques~\cite{joao07pepm}, and powerful type systems~\cite{MiddelkoopDS10}.

  When programming with AGs, modularity is achieved due to the possibility of
  defining and using different aspects of computations as separate attributes.
  Attributes are distinct computation units, typically quite simple and modular,
  that can be combined into elaborated solutions to complex programming
  problems. They can also be analyzed, debugged, and maintained independently
  which eases program development and evolution.

  AGs have proven to be particularly useful to specify computations over trees:
  given one tree, several AG systems such as~\cite{syngen,uuag,lrc,silver} take
  specifications of which values or attributes need to be computed and perform
  these computations. The design and coding efforts put into the creation,
  improvement, and maintenance of these AG systems, however, is tremendous which
  is often an obstacle to achieving the success they deserve.

  An increasingly popular alternative approach to the use of AGs relies on
  embedding them as first-class citizens of general purpose programming
  languages~\cite{Oege00,DBLP:conf/sblp/MartinsFS13,erlangAGs,kiama,doaitse09icfp,balestrieri}.
  This avoids the burden of implementing a totally new language and associated
  system by hosting it in state-of-the-art programming languages. Following this
  approach one then exploits the modern constructions and infrastructure that
  are already provided by those languages and focuses on the particularities of
  the domain specific language being developed.

  Functional zipper~\cite{huet1997zipper} is a powerful abstraction which
  greatly simplifies the implementation of traversal algorithms performing a lot
  of local updates. Functional zippers have successfully been applied to
  construct an AG embedding in
  Haskell~\cite{DBLP:conf/sblp/MartinsFS13,MARTINS20162}. Despite its elegance,
  this solution had a major drawback which prevented its use in real-world
  applications: attributes were not cached, but rather repeatedly recomputed
  which severely hurt performance. Recently, this flaw has been
  eliminated~\cite{FERNANDES2018} and replaced with a different one: the
  approach became intrusive, i.e. to benefit from the embedding user-defined
  data structures have to be adjusted.

  In this paper we present an alternative mechanism to cache attributes based on
  a self-organising infinite grid. This graph is laid on top of the user-defined
  algebraic data type (ADT) and mirrors its structure. The used-defined data type
  itself remains untouched. The embedding is then based on two (rather than one)
  coherent zippers traversing the data structures in parallel. On top of being
  non-intrusive our solution is completely type-safe. Modern Haskell extensions
  such as \texttt{ConstraintKinds} allow us to propagate constraints down in the
  ADT completely eliminating run-time type casts present in the previous
  versions. Another side benefit of using modern Haskell features is a cleaner
  syntax with less code being generated by means of Template Haskell.




\section{Running example}


\newcommand{\withSub}[2]{{\parbox{\widthof{#1#2}}{#1$_\text{#2}$}}}
\newcommand{\itWithSub}[2]{{\parbox{\widthof{#1#2}}{\textit{#1}$_\text{#2}$}}}


In order to illustrate the convenience of our embedding, we will consider the
problem of analyzing the semantic correctness of certain functional programming
excerpts. In particular, we will focus on \text{\texfamily {\bfseries let}} expressions that are common in
functional languages like Haskell~\cite{}, ML~\cite{}, or Scala~\cite{}.
Throughout the paper, we shall refer to these expressions as programs in the
\Let\ language.

A program in the \Let\ language consists of instruction blocks, where each
instruction either:
\begin{enumerate*}[i)]
  \item declares a variable or
  \item defines a nested block.
\end{enumerate*}
When declaring a variable, the programmer must also assigned a value to it; such
value may be a constant, the value of a variable or an expression on these
elements. Ultimately, each block defines a value as an expression on variables
defined in it.

Examples of programs in \Let\ are given next.

\begin{tabbing}\texfamily
\withSub{program}{1}~=~{\bfseries let}~x~=~4~{\bfseries in}~x\\
\texfamily \\
\texfamily \withSub{program}{2}~=~{\bfseries let}~x~=~4~{\bfseries in}~x~+~3\\
\texfamily \\
\texfamily \withSub{program}{3}~=\\
\texfamily ~~{\bfseries let}~x~=~4\\
\texfamily ~~~~~~y~=~{\bfseries let}~w~=~2~{\bfseries in}~x~+~w\\
\texfamily ~~{\bfseries in}~~x~+~y
\end{tabbing}

The values associated with \text{\texfamily \withSub{program}{1}} and \text{\texfamily \withSub{program}{2}} are, quite
straightforwardly, \text{\texfamily 4} and \text{\texfamily 7}, respectively. As of \text{\texfamily \withSub{program}{3}}, its value of
\text{\texfamily 10} is calculated adding the value of \text{\texfamily x}, which is \text{\texfamily 4} and the value of \text{\texfamily y},
i.e., \text{\texfamily 6}. The value of \text{\texfamily y} is obtained by adding the value of \text{\texfamily w}, which is
\text{\texfamily 2}, and the value of \text{\texfamily x}, which, again, is \text{\texfamily 4}.

Our goal is to implement a semantic analyzer that deals with the scope rules of
the \Let\ language. These rules are quite natural and can be described as:
\begin{enumerate}
  \item if a variable is used in a block, it must be declared in that same block
  or in an outer one. The declaration of a variable, however, may occur after its
  use;
  \item a variable identifier may be declared at most once within the same block.
  In an inner block, declaring a variable that has already been declared in an
  outer one is allowed: the identifier in the local scope hides the definition of
  the same identifier in the global one.
\end{enumerate}

Let us now consider a more complex \Let\ program:

\begin{tabbing}\texfamily
\withSub{program}{e}~=\\
\texfamily ~~{\bfseries let}~x~=~y\\
\texfamily ~~~~~~a~=~{\bfseries let}~y~=~4~{\bfseries in}~y~+~w\\
\texfamily ~~~~~~x~=~5\\
\texfamily ~~~~~~y~=~6\\
\texfamily ~~{\bfseries in}~~x~+~a
\end{tabbing}

According to the scope rules that we have just defined, \text{\texfamily \withSub{program}{e}} contains two
errors:
\begin{enumerate*}[1)]
  \item at the outer block, variable \text{\texfamily x} has been declared twice and
  \item at the inner block, the use of variable \text{\texfamily w} has no binding occurrence at
        all.
\end{enumerate*}
Notice that \text{\texfamily y} has been declared at both the inner and the outer levels, which
in itself is not a problem (the inner declaration hides the outer one).

Programs such as the ones we have presented describe the basic block-structure
found in many languages, with the peculiarity that variables can be used before
they are defined.

We aim to implement a program that analyses \Let\ programs and computes a list
containing the identifiers which do not obey the scope rules of the language. In
order to facilitate the debugging phase, we require that the list of invalid
identifiers follows the sequential structure of the program. That is to say,
e.g., that the semantic meaning of processing \text{\texfamily \withSub{program}{e}} is \text{\texfamily [w,\Sp x]}: the use
of the undeclared variable \text{\texfamily w} occurs in line 3 whereas the duplicate
declaration of \text{\texfamily x} occurs in line 4.

Since variables can be used before they are declared, a natural way to implement
such an analysis is to traverse a \Let\ program twice: once to accumulate the
declarations of identifiers (at each block), and again to check the uses of
identifiers against such declarations. The uniqueness of declarations can
already be detected in the first traversal: for each newly encountered
declaration, it is possible to check whether its identifier has already been
declared (in the same level).

In order to implement such program, we first need a representation for programs
in the \Let\ language. For this, we may use the following Haskell data-types:

\begin{tabbing}\texfamily
{\bfseries type}~{\itshape Var}~~~~=~{\itshape String}\\
\texfamily {\bfseries data}~{\itshape Let}~~~~=~{\itshape Let}~{\itshape Decls}~{\itshape Expr}\\
\texfamily {\bfseries data}~{\itshape Decls}~~=~~{\itshape Empty}\\
\texfamily ~~~~~~~~~~~~|~~{\itshape Cons}~~~~{\itshape Var}~{\itshape Expr}~~{\itshape Decls}\\
\texfamily ~~~~~~~~~~~~|~~{\itshape Nested}~~{\itshape Var}~{\itshape Let}~~~{\itshape Decls}\\
\texfamily {\bfseries data}~{\itshape Expr}~~~=~~{\itshape Const}~~~~~{\itshape Int}\\
\texfamily ~~~~~~~~~~~~|~~{\itshape Variable}~~{\itshape Var}\\
\texfamily ~~~~~~~~~~~~|~~{\itshape Plus}~~~{\itshape Expr}~{\itshape Expr}\\
\texfamily ~~~~~~~~~~~~|~~{\itshape Times}~~{\itshape Expr}~{\itshape Expr}
\end{tabbing}

In this representation, \text{\texfamily \withSub{program}{e}} above is defined as:

\begin{tabbing}\texfamily
\withSub{program}{e}~=~{\itshape Let}\\
\texfamily ~~({\itshape Cons}\\
\texfamily ~~~~\char34 x\char34 \\
\texfamily ~~~~({\itshape Variable}~\char34 y\char34 )\\
\texfamily ~~~~({\itshape Nested}\\
\texfamily ~~~~~~\char34 a\char34 \\
\texfamily ~~~~~~({\itshape Let}~({\itshape Cons}~\char34 y\char34 ~({\itshape Const}~4)~{\itshape Empty})~({\itshape Plus}~({\itshape Variable}~\char34 y\char34 )~({\itshape Variable}~\char34 w\char34 )))\\
\texfamily ~~~~~~({\itshape Cons}~\char34 x\char34 ~({\itshape Const}~5)~({\itshape Cons}~\char34 y\char34 ~({\itshape Const}~6)~{\itshape Empty}))\\
\texfamily ~~~~)\\
\texfamily ~~)\\
\texfamily ~~({\itshape Plus}~({\itshape Variable}~\char34 x\char34 )~({\itshape Variable}~\char34 a\char34 ))
\end{tabbing}

Now, we implement name analysis on an abstract \Let\ tree using a set of
composable functions.

The function that implements the first traversal described above needs to pass
all the information that is required for the second traversal. Namely, in order
to compute the final list of errors in the desired order, the second traversal
needs to \textit{where} errors have occurred during the first. Also, the value
of the nesting level must also be carried around because it is on the second
traversal that the first traversal on nested expressions starts (the initial
environment of an inner block is composed by the complete environment of its
outer one).

In order to make available all the information that the second traversal needs,
the first traversal will build a structure such as:

\begin{tabbing}\texfamily
{\bfseries data}~\itWithSub{Let}{2}~~~=~\itWithSub{Let}{2}~\itWithSub{Decls}{2}~{\itshape Expr}\\
\texfamily {\bfseries data}~\itWithSub{Decls}{2}~=~\itWithSub{Empty}{2}\\
\texfamily ~~~~~~~~~~~~|~\itWithSub{Cons}{2}~{\itshape Errors}~{\itshape Expr}~\itWithSub{Decls}{2}\\
\texfamily ~~~~~~~~~~~~|~\itWithSub{Nested}{2}~{\itshape Errors}~{\itshape Lev}~{\itshape Let}~\itWithSub{Decls}{2}
\end{tabbing}


We are now ready to implement the two traversal strategy that we have described.

\begin{tabbing}\texfamily
{\bfseries type}~{\itshape Errors}~~=~[{\itshape String}]\\
\texfamily {\bfseries type}~{\itshape Lev}~~~~~=~{\itshape Int}\\
\texfamily \\
\texfamily semantics~::~{\itshape Let}~\WithMath{->}{\rightarrow}~{\itshape Errors}\\
\texfamily semantics~program~=~errors\\
\texfamily ~{\bfseries where}\\
\texfamily ~~(\withSub{let}{2},~env)~=~\withSub{duplicate}{\textit{Let}}~program~[]~0\\
\texfamily ~~errors~~~~~~~=~\withSub{missing}{\textit{Let}}~\withSub{let}{2}~env\\
\texfamily \\
\texfamily \withSub{duplicate}{\textit{Let}}~::~{\itshape Let}~\WithMath{->}{\rightarrow}~[({\itshape Var},~{\itshape Lev})]~\WithMath{->}{\rightarrow}~{\itshape Lev}~\WithMath{->}{\rightarrow}~(\itWithSub{Let}{2},~[({\itshape Var},~{\itshape Lev})])\\
\texfamily \withSub{duplicate}{\textit{Let}}~({\itshape Let}~decls~expr)~dcli~lev~=~(\itWithSub{Let}{2}~\withSub{decls}{2}~expr,~dclo)\\
\texfamily ~~{\bfseries where}~(\withSub{decls}{2},~dclo)~=~\withSub{duplicate}{\textit{Decls}}~decls~dcli~lev\\
\texfamily \\
\texfamily \withSub{duplicate}{\textit{Decls}}~::~{\itshape Decls}~\WithMath{->}{\rightarrow}~[({\itshape Var},~{\itshape Lev})]~\WithMath{->}{\rightarrow}~{\itshape Lev}~\WithMath{->}{\rightarrow}~(\itWithSub{Decls}{2},~[({\itshape Var},~{\itshape Lev})])\\
\texfamily \withSub{duplicate}{\textit{Decls}}~{\itshape Empty}~dcli~lev~=~(\itWithSub{Empty}{2},~dcli)\\
\texfamily \withSub{duplicate}{\textit{Decls}}~({\itshape Cons}~var~expr~decls)~dcli~lev~=\\
\texfamily ~~(\itWithSub{Cons}{2}~\textit{error}~expr~\withSub{decls}{2},~dclo)\\
\texfamily ~{\bfseries where}\\
\texfamily ~~\textit{error}~~~~~~~~~~~=~{\bfseries if}~(var,~lev)~`elem`~dcli~{\bfseries then}~[var]~{\bfseries else}~[]\\
\texfamily ~~(\withSub{decls}{2},~dclo)~=~\withSub{duplicate}{\textit{Decls}}~decls~((var,~lev)~:~dcli)~lev\\
\texfamily \withSub{duplicate}{\textit{Decls}}~({\itshape Nested}~var~nested~decls)~dcli~lev~=\\
\texfamily ~~(\itWithSub{Nested}{2}~\textit{error}~(lev~+~1)~nested~\withSub{decls}{2},~dclo)\\
\texfamily ~{\bfseries where}\\
\texfamily ~~\textit{error}~~~~~~~~~~~=~{\bfseries if}~(var,~lev)~`elem`~dcli~{\bfseries then}~[var]~{\bfseries else}~[]\\
\texfamily ~~(\withSub{decls}{2},~dclo)~=~\withSub{duplicate}{\textit{Decls}}~decls~((var,~lev)~:~dcli)~lev\\
\texfamily \\
\texfamily \withSub{missing}{\textit{Let}}~::~\itWithSub{Let}{2}~\WithMath{->}{\rightarrow}~[({\itshape Var},~{\itshape Lev})]~\WithMath{->}{\rightarrow}~{\itshape Errors}\\
\texfamily \withSub{missing}{\textit{Let}}~(\itWithSub{Let}{2}~decls~expr)~env~=~\withSub{errors}{1}~\WithMath{++}{+\!\!+}~\withSub{errors}{2}\\
\texfamily ~{\bfseries where}\\
\texfamily ~~\withSub{errors}{1}~=~\withSub{missing}{\textit{Decls}}~decls~env\\
\texfamily ~~\withSub{errors}{2}~=~\withSub{missing}{\textit{Expr}}~expr~env\\
\texfamily \\
\texfamily \withSub{missing}{\textit{Decls}}~::~\itWithSub{Decls}{2}~\WithMath{->}{\rightarrow}~[({\itshape Var},~{\itshape Lev})]~\WithMath{->}{\rightarrow}~{\itshape Errors}\\
\texfamily \withSub{missing}{\textit{Decls}}~(\itWithSub{Cons}{2}~\textit{error}~expr~decls)~env~=~\textit{error}~\WithMath{++}{+\!\!+}~errors\\
\texfamily ~~{\bfseries where}~errors~=~\withSub{missing}{\textit{Expr}}~expr~env~\WithMath{++}{+\!\!+}~\withSub{missing}{\textit{Decls}}~decls~env\\
\texfamily \withSub{missing}{\textit{Decls}}~(\itWithSub{Nested}{2}~\textit{error}~lev~nested~decls)~env~=~\textit{error}~\WithMath{++}{+\!\!+}~errors\\
\texfamily ~{\bfseries where}\\
\texfamily ~~(\withSub{nested}{2},~dclo)~=~\withSub{duplicate}{\textit{Let}}~nested~env~lev\\
\texfamily ~~errors~~~~~~~~~~~=~\withSub{missing}{\textit{Let}}~\withSub{nested}{2}~dclo~\WithMath{++}{+\!\!+}~\withSub{missing}{\textit{Decls}}~decls~env\\
\texfamily \withSub{missing}{\textit{Decls}}~\itWithSub{Empty}{2}~\char95 ~=~[]\\
\texfamily \\
\texfamily \withSub{missing}{\textit{Expr}}~::~{\itshape Expr}~\WithMath{->}{\rightarrow}~[({\itshape Var},~b)]~\WithMath{->}{\rightarrow}~{\itshape Errors}\\
\texfamily \withSub{missing}{\textit{Expr}}~({\itshape Const}~\char95 )~\char95 ~=~[]\\
\texfamily \withSub{missing}{\textit{Expr}}~({\itshape Plus}~\withSub{expr}{1}~\withSub{expr}{2})~env~=\\
\texfamily ~~\withSub{missing}{\textit{Expr}}~\withSub{expr}{1}~env~\WithMath{++}{+\!\!+}~\withSub{missing}{\textit{Expr}}~\withSub{expr}{2}~env\\
\texfamily \withSub{missing}{\textit{Expr}}~({\itshape Times}~\withSub{expr}{1}~\withSub{expr}{2})~env~=\\
\texfamily ~~\withSub{missing}{\textit{Expr}}~\withSub{expr}{1}~env~\WithMath{++}{+\!\!+}~\withSub{missing}{\textit{Expr}}~\withSub{expr}{2}~env\\
\texfamily \withSub{missing}{\textit{Expr}}~({\itshape Variable}~var)~env~=~{\bfseries if}~var~`elem`~map~fst~env~{\bfseries then}~[]~{\bfseries else}~[var]
\end{tabbing}

Notice that \text{\texfamily \withSub{duplicate}{\textit{Let}}} not only computes the total environment (using an
initially empty accumulating parameter), but it also computes a \text{\texfamily \itWithSub{Let}{2}}
intermediate data structure that stores, e.g., the duplicated variables detected
during the first traversal. The second traversal starts with a call to
\text{\texfamily \withSub{missing}{\textit{Let}}} giving that computed data structure and the accumulated environment
as arguments. It produces the list of errors that follows the sequential
structure of the program.

In function \text{\texfamily \withSub{duplicate}{\textit{Decls}}}, for every block we compute: its environment, its
level and its invalid identifiers. The environment defines the context where the
block occurs. It consists of all the identifiers that are visible in the block
(annotated with the level of the block). The level indicates the nesting depth
of a block. Observe that we have to distinguish between the same identifier
declared at different levels, which is valid.

Finally, please note that in the second traversal of a nested expression, in
function \text{\texfamily \withSub{missing}{\textit{Decls}}} for the constructor \text{\texfamily \itWithSub{Nested}{2}}, the program performs the
two traversals to the body of that expression: calls \text{\texfamily \withSub{duplicate}{\textit{Let}}} and
\text{\texfamily \withSub{missing}{\textit{Let}}}.

Although the semantic analysis we have implemented for the \Let\ language is
relatively simple, still we had to face some challenges.

Indeed, scheduling computations was by no means trivial, with intermingled
recursive functions. Also, we had to carefully design and implement intermediate
data structures in order to convey data between traversals. These challenges are
common to functional programming solutions to realistic programming problems.

In lazy (functional) programming languages, one can avoid both the need for
scheduling and for additional data structures by constructing circular
programs~\cite{Bird84}. This strategy, however, compromises the much desired
modular nature of the implementations.

In our work, we seek an elegant and efficient alternative to the construction of
functional programs.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Functional Zippers}
  Zipper is a data structure commonly used in functional programming for
  traversal with fast local updates. The zipper data structure was originally
  conceived by Huet\cite{huet1997zipper} in the context of trees. We will,
  however, first consider a simpler problem: a bidirectional list traversal.

  \paragraph{Lists} Suppose that we would like to update a list at a specific
  position:
\begin{tabbing}\texfamily
~~modify~::~(a~\WithMath{->}{\rightarrow}~[a])~\WithMath{->}{\rightarrow}~{\itshape Int}~\WithMath{->}{\rightarrow}~[a]~\WithMath{->}{\rightarrow}~[a]\\
\texfamily ~~modify~f~i~xs~=~helper~[]~xs~0\\
\texfamily ~~~{\bfseries where}~helper~before~(x~:~after)~!j\\
\texfamily ~~~~~~~~~~~|~j~\WithMath{==}{\equiv}~i~~~~=~before~\WithMath{++}{+\!\!+}~f~x~\WithMath{++}{+\!\!+}~after\\
\texfamily ~~~~~~~~~~~|~\textit{otherwise}~=~helper~(before~\WithMath{++}{+\!\!+}~[x])~after~(j~+~1)\\
\texfamily ~~~~~~~~~helper~\char95 ~[]~\char95 ~=~\textit{error}~\char34 Index~out~of~bounds.\char34 
\end{tabbing}
  Here \text{\texfamily modify} takes an update action \text{\texfamily f}\footnote{\text{\texfamily f} returns a list rather
  than a single element to prevent curious readers from suggesting to use a
  boxed array instead of a list.}, an index \text{\texfamily i}, and a list \text{\texfamily xs} and returns a
  new list with the \text{\texfamily i}'th element replaced with the result of \text{\texfamily f}.%
  First, we ``unpack'' the list into $\text{\texfamily before\Sp =\Sp [}\ttsub{\text{\texfamily xs}}{\text{\texfamily 0}},\dots
  \ttsub{\text{\texfamily xs}}{\text{\texfamily i-1}}\text{\texfamily ]}$, $\text{\texfamily x\Sp =\Sp }\ttsub{\text{\texfamily xs}}{\text{\texfamily i}}$, and
  $\text{\texfamily after\Sp =\Sp [}\ttsub{\text{\texfamily xs}}{\text{\texfamily i+1}},\dots\text{\texfamily ]}$. Then replace \text{\texfamily x} by \text{\texfamily f(x)} and
  finally ``pack'' the result back into a single list. If we do a lot of
  updates, we end up unpacking and packing the list over and over again -- very
  time-consuming for long lists. We would thus like to benefit from fusion
  without explicitly working with the unpacked representation as it is
  bug-prone. A list zipper provides a way to achieve this.

  A zipper consists of a focus (alternatively called a hole) and surrounding
  context\footnote{`\text{\texfamily !}' in front of the type of \text{\texfamily \char95 cxt} is a
  strictness annotation enabled by the \text{\ttfamily BangPatterns} extension. Context can be
  seen as a path from the to the current focus and is always finite, i.e. there
  is no reason for it to be lazy.}:
\begin{tabbing}\texfamily
~~{\bfseries data}~{\itshape Zipper}~a~~=~{\itshape Zipper}~\char123 ~\char95 hole~::~a,~\char95 cxt~::~!({\itshape Context}~a)~\char125 \\
\texfamily ~~{\bfseries data}~{\itshape Context}~a~=~{\itshape Context}~[a]~[a]
\end{tabbing}
  where the \text{\texfamily {\itshape Context}} keeps track of elements to the left (\text{\texfamily before} in
  \text{\texfamily modify}) and to the right (\text{\texfamily after} in \text{\texfamily modify}) of the focus. We can now
  define movements:
\begin{tabbing}\texfamily
~~left~::~{\itshape Zipper}~a~\WithMath{->}{\rightarrow}~{\itshape Maybe}~({\itshape Zipper}~a)\\
\texfamily ~~left~({\itshape Zipper}~\char95 ~~~~({\itshape Context}~[]~\char95 ))~~~~~~~~=~{\itshape Nothing}\\
\texfamily ~~left~({\itshape Zipper}~hole~({\itshape Context}~(l~:~ls)~rs))~=~{\itshape Just}~\$\\
\texfamily ~~~~{\itshape Zipper}~l~\$~{\itshape Context}~ls~(hole~:~rs)\\
\texfamily \\
\texfamily ~~right~::~{\itshape Zipper}~a~\WithMath{->}{\rightarrow}~{\itshape Maybe}~({\itshape Zipper}~a)\\
\texfamily ~~right~({\itshape Zipper}~\char95 ~~~~({\itshape Context}~\char95 ~[]))~~~~~~~~=~{\itshape Nothing}\\
\texfamily ~~right~({\itshape Zipper}~hole~({\itshape Context}~ls~(r~:~rs)))~=~{\itshape Just}~\$\\
\texfamily ~~~~{\itshape Zipper}~r~\$~{\itshape Context}~(hole~:~ls)~rs
\end{tabbing}
  and functions for entering and leaving the zipper:
\begin{tabbing}\texfamily
~~enter~::~[a]~\WithMath{->}{\rightarrow}~{\itshape Maybe}~({\itshape Zipper}~a)\\
\texfamily ~~enter~[]~~~~~~~=~{\itshape Nothing}\\
\texfamily ~~enter~(x~:~xs)~=~{\itshape Just}~\$~{\itshape Zipper}~x~({\itshape Context}~[]~xs)\\
\texfamily \\
\texfamily ~~leave~::~{\itshape Zipper}~a~\WithMath{->}{\rightarrow}~[a]\\
\texfamily ~~leave~({\itshape Zipper}~hole~({\itshape Context}~ls~rs))~=~reverse~ls~\WithMath{++}{+\!\!+}~hole~:~rs
\end{tabbing}


  Finally, we define a local version of our \text{\texfamily modify} function (\TODO{Boy, is
  this function ugly...})
\begin{tabbing}\texfamily
~~modify~::~(a~\WithMath{->}{\rightarrow}~[a])~\WithMath{->}{\rightarrow}~{\itshape Zipper}~a~\WithMath{->}{\rightarrow}~{\itshape Maybe}~({\itshape Zipper}~a)\\
\texfamily ~~modify~f~({\itshape Zipper}~hole~({\itshape Context}~ls~rs))~=~{\bfseries case}~f~hole~{\bfseries of}\\
\texfamily ~~~~(x~:~xs)~\WithMath{->}{\rightarrow}~{\itshape Just}~\$~{\itshape Zipper}~x~({\itshape Context}~ls~(xs~\WithMath{++}{+\!\!+}~rs))\\
\texfamily ~~~~[]~~~~~~~\WithMath{->}{\rightarrow}~{\bfseries case}~rs~{\bfseries of}\\
\texfamily ~~~~~~(r~:~rs')~\WithMath{->}{\rightarrow}~{\itshape Just}~\$~{\itshape Zipper}~r~({\itshape Context}~ls~rs')\\
\texfamily ~~~~~~[]~~~~~~~~\WithMath{->}{\rightarrow}~{\bfseries case}~ls~{\bfseries of}\\
\texfamily ~~~~~~~~(l~:~ls')~\WithMath{->}{\rightarrow}~{\itshape Just}~\$~{\itshape Zipper}~l~({\itshape Context}~ls'~rs)\\
\texfamily ~~~~~~~~[]~~~~~~~~\WithMath{->}{\rightarrow}~{\itshape Nothing}
\end{tabbing}
  using which we can perform multiple updates efficiently and with minimal code
  bloat\footnote{%
  Operator \text{\ttfamily \char62{}\char61{}\char62{}} comes from \text{\texfamily {\itshape {\itshape Control}.Monad}} module in \text{\ttfamily base}
  and has the following signature:%
\begin{tabbing}\texfamily
~~(>=>)~::~{\itshape Monad}~m~=>~(a~\WithMath{->}{\rightarrow}~m~b)~\WithMath{->}{\rightarrow}~(b~\WithMath{->}{\rightarrow}~m~c)~\WithMath{->}{\rightarrow}~a~\WithMath{->}{\rightarrow}~m~c
\end{tabbing}
%
  }:
\begin{tabbing}\texfamily
~~modifyExample~::~{\itshape IO}~()\\
\texfamily ~~modifyExample~=~print~\$\\
\texfamily ~~~~enter~@{\itshape Int}~>=>~right\\
\texfamily ~~~~~~~~~~~~~~~~~>=>~right\\
\texfamily ~~~~~~~~~~~~~~~~~>=>~modify~(const~[])\\
\texfamily ~~~~~~~~~~~~~~~~~>=>~modify~(return~\WithMath{.}{\circ}~(+1))\\
\texfamily ~~~~~~~~~~~~~~~~~>=>~left\\
\texfamily ~~~~~~~~~~~~~~~~~>=>~modify~(return~\WithMath{.}{\circ}~negate)\\
\texfamily ~~~~~~~~~~~~~~~~~>=>~return~\WithMath{.}{\circ}~leave~\$~[1,~2,~3,~4,~5]
\end{tabbing}

  \paragraph{Trees} Consider now a binary tree data structure:
\begin{tabbing}\texfamily
~~{\bfseries data}~{\itshape Tree}~a~=~{\itshape Leaf}~!a~|~{\itshape Fork}~({\itshape Tree}~a)~({\itshape Tree}~a)
\end{tabbing}
  A binary tree zipper is slightly more insteresting than the list zipper,
  because we can move up and down the tree as well as left and right. The zipper
  again consists of a hole (a subtree we are focused on) and its surrounding
  context (a path from the hole to the root of the tree):
\begin{tabbing}\texfamily
~~{\bfseries data}~{\itshape Zipper}~a~~=~{\itshape Zipper}~\char123 ~\char95 hole~::~{\itshape Tree}~a,~\char95 cxt~::~!({\itshape Context}~a)~\char125 \\
\texfamily ~~{\bfseries data}~{\itshape Context}~a~=~{\itshape Top}\\
\texfamily ~~~~~~~~~~~~~~~~~|~{\itshape Left}~!({\itshape Context}~a)~({\itshape Tree}~a)\\
\texfamily ~~~~~~~~~~~~~~~~~|~{\itshape Right}~({\itshape Tree}~a)~!({\itshape Context}~a)
\end{tabbing}
  To move the zipper down, we ``unpack'' the current hole:
\begin{tabbing}\texfamily
~~down~::~{\itshape Zipper}~a~\WithMath{->}{\rightarrow}~{\itshape Maybe}~({\itshape Zipper}~a)\\
\texfamily ~~down~({\itshape Zipper}~({\itshape Leaf}~\char95 )~~~\char95 )~~~=~{\itshape Nothing}\\
\texfamily ~~down~({\itshape Zipper}~({\itshape Fork}~l~r)~cxt)~=~{\itshape Just}~\$~{\itshape Zipper}~r~({\itshape Right}~l~cxt)
\end{tabbing}
  \text{\texfamily {\itshape Context}} stores everything we need to reconstruct the hole, and \text{\texfamily up} does
  exactly that:
\begin{tabbing}\texfamily
~~up~::~{\itshape Zipper}~a~\WithMath{->}{\rightarrow}~{\itshape Maybe}~({\itshape Zipper}~a)\\
\texfamily ~~up~({\itshape Zipper}~\char95 ~{\itshape Top})~=~{\itshape Nothing}\\
\texfamily ~~up~({\itshape Zipper}~l~({\itshape Left}~cxt~r))~=~{\itshape Just}~\$~{\itshape Zipper}~({\itshape Fork}~l~r)~cxt\\
\texfamily ~~up~({\itshape Zipper}~r~({\itshape Right}~l~cxt))~=~{\itshape Just}~\$~{\itshape Zipper}~({\itshape Fork}~l~r)~cxt
\end{tabbing}
  Implementations of \text{\texfamily left}, \text{\texfamily right}, and \text{\texfamily enter} are very similar to the
  list zipper case and are left as an exercise for the reader. \text{\texfamily leave} differs
  slightly in that we now move all the way up rather than left:
\begin{tabbing}\texfamily
~~leave~::~{\itshape Zipper}~a~\WithMath{->}{\rightarrow}~{\itshape Tree}~a\\
\texfamily ~~leave~z~=~{\bfseries case}~up~z~{\bfseries of}\\
\texfamily ~~~~{\itshape Just}~z'~\WithMath{->}{\rightarrow}~leave~z'\\
\texfamily ~~~~{\itshape Nothing}~\WithMath{->}{\rightarrow}~\char95 hole~z
\end{tabbing}


  \paragraph{Generic Zipper} The list and binary tree zippers we have considered
  so far are homogeneous zippers: the type of the focus does not change upon zipper
  movement. Such a zipper can be a very useful abstraction. For example, a
  well-known window manager XMonad\cite{xmonad} uses a rose tree zipper to track
  the window under focus. For other tasks, however, one might need to traverse
  heterogeneous structures. A zipper that can accomodate such needs is usually
  called a \textit{generic zipper} as it relies only on the generic structure of
  Algebraic Data Types (ADTs). One can view an ADT as an Abstract Syntax Tree
  (AST) where each node is a Haskell constructor rather than a syntax construct.

  The generic zipper we will use is very similar to the one presented
  in\cite{adams2010syz}. The most common technique in Haskell for supporting
  heterogeneous types is Existential Quantification. However, not every type can
  act as a hole. To support moving down the tree, we need the hole to be
  \textit{dissectible}, i.e. we would like to be able to dissect the value into
  the constructor and its arguments. Even though \text{\texfamily {\itshape Data}.{\itshape Data}.gfoldl} allows us to
  achieve this, we define out own typeclass which additionally allows us to
  propagate down arbitrary constraints:
\begin{tabbing}\texfamily
~~{\bfseries class}~{\itshape Dissectible}~(c~::~{\itshape Type}~\WithMath{->}{\rightarrow}~{\itshape Constraint})~(a~::~{\itshape Type})~{\bfseries where}\\
\texfamily ~~~~dissect~::~a~\WithMath{->}{\rightarrow}~{\itshape Left}~c~a\\
\texfamily \\
\texfamily ~~{\bfseries data}~{\itshape Left}~c~expects~{\bfseries where}\\
\texfamily ~~~~{\itshape LOne}~~::~b~\WithMath{->}{\rightarrow}~{\itshape Left}~c~b\\
\texfamily ~~~~{\itshape LCons}~::~(c~b,~{\itshape Dissectible}~c~b)\\
\texfamily ~~~~~~~~~~=>~{\itshape Left}~c~(b~\WithMath{->}{\rightarrow}~expects)~\WithMath{->}{\rightarrow}~b~\WithMath{->}{\rightarrow}~{\itshape Left}~c~expects
\end{tabbing}
  For example, here is how we can make \text{\texfamily {\itshape Tree}} an instance of \text{\texfamily {\itshape Disssectible}}
\begin{tabbing}\texfamily
~~{\bfseries instance}~c~({\itshape Tree}~a)~=>~{\itshape Dissectible}~c~({\itshape Tree}~a)~{\bfseries where}\\
\texfamily ~~~~dissect~({\itshape Fork}~l~r)~=~{\itshape LOne}~{\itshape Fork}~`{\itshape LCons}`~l~`{\itshape LCons}`~r\\
\texfamily ~~~~dissect~x~=~{\itshape LOne}~x
\end{tabbing}
  We can unpack a \text{\texfamily {\itshape Fork}} and the zipper will thus be able to go down. \text{\texfamily {\itshape Leaf}}s,
  however, are left untouched and trying to go down from a \text{\texfamily {\itshape Leaf}} will return
  \text{\texfamily {\itshape Nothing}}.

  To allow the zipper to move left and right, we need a means to encode
  arguments to the right of the hole. Following Adams et al, we define a GADT
  representing constructor arguments to the right of the hole:
\begin{tabbing}\texfamily
~~{\bfseries data}~{\itshape Right}~c~provides~r~{\bfseries where}\\
\texfamily ~~~~{\itshape RNil}~~::~{\itshape Right}~c~r~r\\
\texfamily ~~~~{\itshape RCons}~::~(c~b,~{\itshape Dissectible}~c~b)\\
\texfamily ~~~~~~~~~~=>~b~\WithMath{->}{\rightarrow}~{\itshape Right}~c~provides~r~\WithMath{->}{\rightarrow}~{\itshape Right}~c~(b~\WithMath{->}{\rightarrow}~provides)~r
\end{tabbing}
  For example, for a tuple \text{\texfamily ({\itshape Int},\Sp {\itshape Int},\Sp {\itshape Int},\Sp {\itshape Int},\Sp {\itshape Int},\Sp {\itshape Int})}, we can have
\begin{tabbing}\texfamily
~~lefts~=~{\itshape LOne}~(,,,,,)~`{\itshape LCons}`~1~`{\itshape LCons}`~2~`{\itshape LCons}`~3\\
\texfamily ~~hole~=~4\\
\texfamily ~~rights~=~5~`{\itshape RCons}`~6~`{\itshape RCons}`~{\itshape RNil}
\end{tabbing}
  generalising this a little, we arrive at:
\begin{tabbing}\texfamily
~~{\bfseries data}~{\itshape LocalContext}~c~hole~rights~parent~=\\
\texfamily ~~~~{\itshape LocalContext}~!({\itshape Left}~c~(hole~\WithMath{->}{\rightarrow}~rights))~!({\itshape Right}~c~rights~parent)\\
\texfamily \\
\texfamily ~~{\bfseries data}~{\itshape Context}~::~({\itshape Type}~\WithMath{->}{\rightarrow}~{\itshape Constraint})~\WithMath{->}{\rightarrow}~{\itshape Type}~\WithMath{->}{\rightarrow}~{\itshape Type}~\WithMath{->}{\rightarrow}~{\itshape Type}~{\bfseries where}\\
\texfamily ~~~~{\itshape RootContext}~::~\char'24~c~root.~{\itshape Context}~c~root~root\\
\texfamily ~~~~(:>)~::~\char'24~c~parent~root~hole~rights.~(c~parent,~{\itshape Dissectible}~c~parent)\\
\texfamily ~~~~~~~~~=>~!({\itshape Context}~c~parent~root)\\
\texfamily ~~~~~~~~~\WithMath{->}{\rightarrow}~!({\itshape LocalContext}~c~hole~rights~parent)\\
\texfamily ~~~~~~~~~\WithMath{->}{\rightarrow}~{\itshape Context}~c~hole~root
\end{tabbing}
  And just like before the \text{\texfamily {\itshape Zipper}} is a product of the hole and context:
\begin{tabbing}\texfamily
~~{\bfseries data}~{\itshape Zipper}~(c~::~{\itshape Type}~\WithMath{->}{\rightarrow}~{\itshape Constraint})~(root~::~{\itshape Type})~=\\
\texfamily ~~~~\char'24~hole.~(c~hole,~{\itshape Dissectible}~c~hole)~=>\\
\texfamily ~~~~~~{\itshape Zipper}~\char123 ~\char95 zHole~::~!hole\\
\texfamily ~~~~~~~~~~~~~,~\char95 zCxt~~::~!({\itshape Context}~c~hole~root)\\
\texfamily ~~~~~~~~~~~~~\char125 
\end{tabbing}

  Implementation of movements is quite straightforward and is left out. Please,
  refer to (\TODO{github repo}) for complete code. We now consider a rather
  interesting application of generic zipper: embedding of attribute grammars.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Attribute Grammars}
  Attribute grammars (AGs) are an extension of context-free grammars that allow
  to specify context-sensitive syntax as well as the semantics. AGs achieve it
  by associating a set of attributes with each grammar symbol. These attributes
  are defined using evaluation rules assiciated with production rules of the
  context-free grammar.

  Attributes are then usually divided into two disjoint sets: synthesized
  attributes and the inherited attributes. Such distinction is required for the
  construction of a dependency graph. It is then used for specification of the
  evaluation order and detection of circularity. In the zipper-based embedding of
  attribute grammars we make no use of a dependency graph and thus do not divide
  attributes into classes.

  Let us consider the repmin problem as an example of a problem that requires
  multiple traversals:
  \begin{displayquote}
    Given a tree of integers, replace every integer with the
    minimum integer in the tree, in one pass.
  \end{displayquote}
  The classical solution is the following circular program:
\begin{tabbing}\texfamily
~~repmin~::~{\itshape Tree}~{\itshape Int}~\WithMath{->}{\rightarrow}~{\itshape Tree}~{\itshape Int}\\
\texfamily ~~repmin~t~=~t'\\
\texfamily ~~~~{\bfseries where}~(t',~m')~=~go~t~m'\\
\texfamily ~~~~~~~~~~go~({\itshape Leaf}~x~~~~)~m~=~({\itshape Leaf}~m,~x)\\
\texfamily ~~~~~~~~~~go~({\itshape Fork}~xs~ys)~m~=~({\itshape Fork}~xs'~ys',~min~\parbox[][3.5pt][t]{\widthof{mx}}{m$_{\text{x}}$}~\parbox[][3.5pt][t]{\widthof{my}}{m$_{\text{y}}$})\\
\texfamily ~~~~~~~~~~~~{\bfseries where}~(xs',~\parbox[][3.5pt][t]{\widthof{mx}}{m$_{\text{x}}$})~=~go~xs~m\\
\texfamily ~~~~~~~~~~~~~~~~~~(ys',~\parbox[][3.5pt][t]{\widthof{my}}{m$_{\text{y}}$})~=~go~ys~m
\end{tabbing}

  Although quite elegant, the code lacks modularity and is very difficult to
  reason about. Attribute Grammars provide a more modular approach. Viera et
  al\cite{viera2009agsfly} identified three steps for solving repmin: computing
  the minimal value, passing it down from the root to the leaves, and
  constructing the resulting tree. We can associate each step with an
  attribute\cite{swierstra1998designing}:
  \begin{itemize}
  \item A synthesized attribute \text{\texfamily localMin\Sp ::\Sp {\itshape Int}} represents the minimum value
        of a subtree. Computing the minimal value thus corresponds to evaluation
        of the \text{\texfamily localMin} attribute for the root tree.
  \item An inherited attribute \text{\texfamily globalMin\Sp ::\Sp {\itshape Int}} is used to pass down the
        minimal value.
  \item Finally, a synthesized attribute \text{\texfamily updated\Sp ::\Sp {\itshape Tree}\Sp {\itshape Int}} is the subtree
        with leaf values replaced by values of their \text{\texfamily globalMin} attributes. The
        solution is thus the value of \text{\texfamily updated} attribute for the root tree.
  \end{itemize}
  The obtained AG is presented in figure~\ref{fig:repmin-AG}. \TODO{Do we
  actually need to explain the algorithms here? It seems a little bit childish
  to explain how to compute the minimum of a binary tree... If we absolutely
  have to explain stuff, maybe just put it in the caption.}

\begin{figure}
\centering
\fbox{\parbox{\linewidth}{%
\begin{tabbing}\texfamily
~~SYN~{\itshape Tree}~{\itshape Int}~[localMin~:~{\itshape Int}]\\
\texfamily ~~SEM~{\itshape Tree}~{\itshape Int}~|~{\itshape Leaf}~lhs.localMin~=~@value\\
\texfamily ~~~~~~~~~~~~~~~|~{\itshape Fork}~lhs.localMin~=~min~@left.localMin\\
\texfamily ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~@right.localMin\\
\texfamily \\
\texfamily ~~SYN~{\itshape Tree}~{\itshape Int}~[updated~:~{\itshape Tree}~{\itshape Int}]\\
\texfamily ~~SEM~{\itshape Tree}~{\itshape Int}~|~{\itshape Leaf}~lhs.updated~=~{\itshape Leaf}~@lhs.globalMin\\
\texfamily ~~~~~~~~~~~~~~~|~{\itshape Fork}~lhs.updated~=~{\itshape Fork}~@left.updated\\
\texfamily ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~@right.updated\\
\texfamily \\
\texfamily \\
\texfamily ~~INH~{\itshape Tree}~{\itshape Int}~[~globalMin~:~{\itshape Int}~]\\
\texfamily ~~SEM~{\itshape Tree}~{\itshape Int}~|~{\itshape Fork}~left.globalMin~~=~@lhs.globalMin\\
\texfamily ~~~~~~~~~~~~~~~~~~~~~~right.globalMin~=~@lhs.globalMin\\
\texfamily \\
\texfamily ~~DATA~{\itshape Root}~|~{\itshape Root}~tree~:~{\itshape Tree}~{\itshape Int}\\
\texfamily ~~SEM~~{\itshape Root}~|~{\itshape Root}~tree.globalMin~=~@tree.localMin
\end{tabbing}
%
}}
\caption{%
  Attribute grammar for repmin. The syntax is closely mirrors the one used
  in\cite{swierstra1998designing}. \text{\texfamily SYN} and \text{\texfamily INH} introduce synthesized
  and inherited attributes respectively. \text{\texfamily SEM} is used for defining semantic
  rules. A new data type \text{\texfamily {\itshape Root}} is introduced as it is common in the AG setting
  to ``connect'' \text{\texfamily localMin} with \text{\texfamily globalMin}.
}
\label{fig:repmin-AG}
\end{figure}

  We now move on to embed this attribute grammar into Haskell. Semantic rules
  simply become functions, which, given a zipper, return values of the
  attributes. For example,
\begin{tabbing}\texfamily
~~localMin~::~{\itshape Zipper}~({\itshape WhereAmI}~{\itshape Position})~({\itshape Tree}~{\itshape Int})~\WithMath{->}{\rightarrow}~{\itshape Int}\\
\texfamily ~~localMin~z@({\itshape Zipper}~hole~\char95 )~=~{\bfseries case}~whereami~hole~{\bfseries of}\\
\texfamily ~~~~\parbox{\widthof{CLeaf}}{\textit{C}$_\text{\textit{Leaf}}$}~\WithMath{->}{\rightarrow}~{\bfseries let}~{\itshape Leaf}~x~=~hole~{\bfseries in}~x\\
\texfamily ~~~~\parbox{\widthof{CFork}}{\textit{C}$_\text{\textit{Fork}}$}~\WithMath{->}{\rightarrow}~{\bfseries let}~{\itshape Just}~l~=~child~0~z;~{\itshape Just}~r~=~child~1~z\\
\texfamily ~~~~~~~~~~~~~~{\bfseries in}~min~(localMin~l)~(localMin~r)
\end{tabbing}

  Apart from the type signature, the code is pretty straightforward and closely
  mirrors the AG we defined earlier. \text{\texfamily whereami} function allows us to ``look
  around'' and returns the position of the zipper. Thus the \text{\texfamily {\bfseries case}} corresponds
  to the pattern matches on the left of the vertical bars on
  figure~\ref{fig:repmin-AG}.

  Position of the zipper is encoded using the following GADT which can be
  generated automatically using Template Haskell:
\begin{tabbing}\texfamily
~~{\bfseries data}~{\itshape Position}~::~{\itshape Type}~\WithMath{->}{\rightarrow}~{\itshape Type}~{\bfseries where}\\
\texfamily ~~~~\parbox{\widthof{CLeaf}}{\textit{C}$_\text{\textit{Leaf}}$}~::~{\itshape Position}~({\itshape Tree}~{\itshape Int})\\
\texfamily ~~~~\parbox{\widthof{CFork}}{\textit{C}$_\text{\textit{Fork}}$}~::~{\itshape Position}~({\itshape Tree}~{\itshape Int})
\end{tabbing}
  Parametrization on the type of the hole allows the code like
  \text{\texfamily {\bfseries let}\Sp {\itshape Leaf}\Sp x\Sp =\Sp hole\Sp {\bfseries in}\Sp x} to typecheck, even though the generic zipper itself knows close
  to nothing about the type of the hole. It might seem trivial at first, because
  the binary tree zipper is in fact homogeneous. The ``position trick'' however
  extends also to heterogeneous zippers which we will encounter in more advanced
  examples.

\begin{tabbing}\texfamily
~~child~::~{\itshape Int}~\WithMath{->}{\rightarrow}~{\itshape Zipper}~cxt~root~\WithMath{->}{\rightarrow}~{\itshape Maybe}~({\itshape Zipper}~cxt~root)
\end{tabbing}
  \text{\texfamily child\Sp n} moves the zipper to the \text{\texfamily n}'th child, if there is one.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Related Work}\label{sec:related-work}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion}\label{sec:conclusion}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Acknowledgements}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% As per the LLNCS guidelines
\bibliographystyle{splncs04}
\bibliography{References}

\end{document}

